# -----------------------------------------------------------------------------
# HMI Helper File Generator Script
#
# Author: Gemini
# Date: 2025-07-27
#
# Description:
# This script acts as a developer convenience tool. It parses the manually
# created MyData.h file (the single source of truth for the data structure)
# and automatically generates the following helper files:
#
# 1. A template .hal file for LinuxCNC with descriptive signal names.
# 2. A Markdown documentation table that clearly shows the data mapping.
#
# This script is intended to be run manually by the developer after any
# changes are made to the MyData.h file.
# -----------------------------------------------------------------------------

import os
import re

# --- FILE PATHS (ABSOLUTE) ---
# Get the absolute path of the directory where this script is located (i.e., .../scripts/)
script_dir = os.path.dirname(os.path.abspath(__file__))
# Get the project root directory by going one level up from the script's directory
project_root = os.path.dirname(script_dir)

# Build absolute paths for all files, starting from the project root
SOURCE_H_FILE = os.path.join(project_root, "src", "esp1", "MyData.h")
OUTPUT_DIR_GEN = os.path.join(project_root, "generated_config")
HAL_PATH = os.path.join(OUTPUT_DIR_GEN, "hmi.hal")
MD_PATH = os.path.join(OUTPUT_DIR_GEN, "mapping_doku.md")


# --- DATA TYPE MAPPING ---
# Maps C++ types to their corresponding sizes in bytes.
TYPE_INFO = {
    "int32_t": {"size": 4}, "uint32_t": {"size": 4},
    "int16_t": {"size": 2}, "uint16_t": {"size": 2},
    "uint8_t": {"size": 1}, "float": {"size": 4}
}

def parse_mydata_h():
    """
    Parses the source MyData.h file to extract the variable definitions
    for both the IN and OUT data buffers using a robust multi-step method.
    Returns two lists of dictionaries (in_map, out_map).
    """
    in_map, out_map = [], []
    
    try:
        with open(SOURCE_H_FILE, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"ERROR: Source file not found at {SOURCE_H_FILE}. Aborting.")
        return None, None

    # 1. Clean the file content of non-standard characters.
    content = content.replace(u'\xa0', ' ')

    # 2. Define regex patterns
    # This pattern finds all typedef union blocks for PROCBUFFER_IN or PROCBUFFER_OUT
    union_regex = re.compile(r'(typedef\s+union.*?PROCBUFFER_(?:IN|OUT);)', re.DOTALL)
    # This pattern finds the content inside the 'struct { ... } Cust;'
    struct_content_regex = re.compile(r'struct\s*\{(.*?)\s*\} Cust;', re.DOTALL)
    # This pattern extracts individual variable declarations
    var_regex = re.compile(r"^\s*(\w+)\s+([\w_]+)(?:\[(\d+)\])?\s*;\s*(?://\s*(.*))?")

    # 3. Find all union blocks in the file
    union_blocks = union_regex.findall(content)

    for block in union_blocks:
        target_map = None
        if "PROCBUFFER_IN" in block:
            target_map = in_map
        elif "PROCBUFFER_OUT" in block:
            target_map = out_map
        else:
            continue

        struct_match = struct_content_regex.search(block)
        if struct_match:
            struct_content = struct_match.group(1)
            for line in struct_content.strip().splitlines():
                match = var_regex.match(line.strip())
                if match and not match.group(2).startswith('__reserved'):
                    c_type, name, array_size, desc = match.groups()
                    full_type = f"{c_type}[{array_size}]" if array_size else c_type
                    target_map.append({'name': name, 'type': full_type, 'desc': (desc or "").strip()})

    return in_map, out_map

def generate_hal_file(in_map, out_map):
    """Generates the hmi.hal template file for LinuxCNC."""
    print(f"--> Generating {HAL_PATH}...")
    with open(HAL_PATH, "w", encoding='utf-8') as f:
        f.write("# -------------------------------------------------------------------\n")
        f.write("# LinuxCNC HAL File Template for ESP32 HMI\n")
        f.write("# WARNING: THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT.\n")
        f.write(f"# It was generated based on the structure found in {SOURCE_H_FILE}.\n")
        f.write("# Instead, include it in your main HAL file and connect the generated signals.\n")
        f.write("# -------------------------------------------------------------------\n\n")

        f.write("# --- IN Signals: Data from HMI to LinuxCNC ---\n")
        for item in in_map:
            name = item['name']
            base_type = item['type'].split('[')[0]
            if '[' in item['type']:
                size = int(item['type'].split('[')[1][:-1])
                if base_type == "uint8_t":
                    for i in range(size):
                        for j in range(8):
                            f.write(f"net hmi-{name}-{i*8+j} <= easycat.0.pdo-in.{name}-{i}.{j}\n")
                else:
                    for i in range(size):
                        f.write(f"net hmi-{name}-{i} <= easycat.0.pdo-in.{name}-{i}\n")
            else:
                f.write(f"net hmi-{name} <= easycat.0.pdo-in.{name}\n")
            f.write("\n")

        f.write("\n# --- OUT Signals: Data from LinuxCNC to HMI ---\n")
        for item in out_map:
            name = item['name']
            if '[' in item['type']:
                 size = int(item['type'].split('[')[1][:-1])
                 for i in range(size):
                     f.write(f"net lcnc-{name}-{i} => easycat.0.pdo-out.{name}-{i}\n")
            else:
                 f.write(f"net lcnc-{name} => easycat.0.pdo-out.{name}\n")
            f.write("\n")
    print(f"    SUCCESS: Wrote {HAL_PATH}")

def generate_markdown_table(in_map, out_map):
    """Generates a Markdown table for documentation."""
    print(f"--> Generating {MD_PATH}...")
    with open(MD_PATH, "w", encoding='utf-8') as f:
        f.write("# Auto-Generated EtherCAT Data Mapping\n\n")
        f.write(f"This document describes the exact byte-for-byte layout of the process data based on `{SOURCE_H_FILE}`.\n\n")
        f.write("| Direction | Byte Offset | Size (Bytes) | C++ Type | Variable Name | Description |\n")
        f.write("|:---|:---|:---|:---|:---|:---|\n")
        
        offset = 0
        for item in in_map:
            c_type = item['type'].split('[')[0]
            size = TYPE_INFO.get(c_type, {"size": 0})["size"] * (int(item['type'].split('[')[1][:-1]) if '[' in item['type'] else 1)
            f.write(f"| IN | {offset} | {size} | `{item['type']}` | `{item['name']}` | {item['desc']} |\n")
            offset += size
            
        offset = 0
        for item in out_map:
            c_type = item['type'].split('[')[0]
            size = TYPE_INFO.get(c_type, {"size": 0})["size"] * (int(item['type'].split('[')[1][:-1]) if '[' in item['type'] else 1)
            f.write(f"| OUT | {offset} | {size} | `{item['type']}` | `{item['name']}` | {item['desc']} |\n")
            offset += size
    print(f"    SUCCESS: Wrote {MD_PATH}")

def main():
    """Main execution workflow for the generator script."""
    print("--- Running HMI Helper File Generator ---")
    os.makedirs(OUTPUT_DIR_GEN, exist_ok=True)
    
    in_map, out_map = parse_mydata_h()
    
    if in_map is None or (not in_map and not out_map):
        print(f"WARNING: Could not parse any variables from {SOURCE_H_FILE}. Output files will be empty.")
        return

    generate_hal_file(in_map, out_map)
    generate_markdown_table(in_map, out_map)
    
    print("--- Generation complete. ---")
    print(f"Found {len(in_map)} IN variables and {len(out_map)} OUT variables.")

if __name__ == "__main__":
    main()